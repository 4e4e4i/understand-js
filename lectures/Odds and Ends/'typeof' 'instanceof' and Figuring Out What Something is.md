# 'typeof', 'instanceof', and Figuring Out What Something Is

Мы уже видели как происходит динамическое типизирование в JS, давайте попробуем несколько интересных вещей и может
быть немного опасных.

Но что если у вас есть переменная и ты хочешь знать какой у нее тип, програмно? У JavaScript есть пару утилит, которые
могут помочь нам с этим, но они не идеальны. Это **typeof**, **instanceof**.

```javascript
var a = 3;
console.log(typeof a); // number

var b = "Hello";
console.log(typeof b); // string

var c = {};
console.log(typeof c); // object

var d = [];
console.log(typeof d); //weird!
console.log(Object.prototype.toString.call(d)); // better!

function Person(name) {
  this.name = name;
}

var e = new Person('Jane');
console.log(typeof e);
console.log(e instanceof Person);
```

Я приготовил несколько переменных различных типов и я использую **typeof** и **instanceof** ключевые слова.

По началу typeof сообщает нам, что мы ожидаем. Какого типа этот элемент. Для примера первой переменной я привел числовой
примитив и мы видим, что консоль лог выводит его тип **number**. Заметим что пишется тип с прописной буквой.
Я не использую функцию-конструктор Number с заглавной N, которого мы обычно хотим избежать. То что возвращает typeof - 
строка.

Переменная b - строка, поэтому typeof возвращает нам строку со значением string.

Переменная c - объект, он мог бы иметь свойства или методы, это не важно. Когда мы используем typeof и передаем туда объект,
получаем слово, строку - object.

Переменная d будет немного странной. Массивы - это объекты. Поэтому когда мы передаем в typeof какой-либо массив, то
он возврщает object. Это не совсем не полезно. Есть несколько способов обойти это. Один из них - использовать прототипную
концепцию и концепт .call, которую мы уже видели. Когда мы исользуем typeof на массиве, мы получаем строку - object.
Если я попробую например написать 

```javascript
console.log(d.toString()); // получаем пустую строку
```

Потому что на самом деле метод toString пытается взять содержимое массива и конвертировать его в строку. Это нам, конечно,
не поможет. Тем не менее, на этом базовом объекте, за которым я наблюдаю, в его прототипе есть свойство toString, в прототие
этой функции-конструктора, которой является базовым объектом toString. И затем вместо того чтобы взаимодействовать c
прототипом функции-конструктора этого объекта, я делаю **.call**, который, как вы знаете означает "вызови эту функцию, и
скажи ей, на что переменная this должна указывать". Так как toString использует перменную this для вывода ее значения, я
говорю "возьми мой массив и вызови toString вглубь цепочки прототипа." И этот трюк выдаёт мне вот такую вот строку:

```javascript
console.log(Object.prototype.toString.call(d)); // [object Array]
```

Затем у нас есть Person функция-конструктор. Мы называем ее с заглавной буквы и не возвращаем ничего. В ней мы устанавливаем
переменную равную new Person.

```javascript
function Person(name) {
    this.name = name;
}

var e = new Person('Jane');
```

И давайте взглянем на typeof переменной **e**. Это снова объект. Но это уже ожидаемо, потому что это всего-лишь объект.
Есть и другое ключевое слово, называемое **instanceof**, оно говорим мне, если какие-то объекты внизу цепи прототипа.
Если где-то внизу цепочки прототипов, я найду тип этого объекта, то он вернет true.

Последними у нас идут undefined и null. Ну undefined - это не пустота, поэтому его тип - undefined. 

И последнее, что было ошибкой в JavaScript с незапамятных времен, так много, что есть библиотеки и много кода, которые 
полагаются на то, что так, и они никогда не исправляли его. Если вы попытаетесь сделать typeof и что-то будет **null**,
вы получите объект. Я знаю, это ужасно, но это баг и он был слишком давно, чтобы были какие-то возможности поправить его.

Ну и напоследок, давайте попробуем сделать так:

```javascript
var z = function() { };
console.log(typeof z); // return string - function
```

