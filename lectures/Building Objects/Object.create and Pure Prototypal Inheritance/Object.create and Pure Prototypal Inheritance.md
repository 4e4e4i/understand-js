# Object.create and Pure Prototypal Inheritance

Мы уже видели что функции-конструкторы были разработаны, чтобы подражать другим языкам,
которые не реализуют прототипное наследование и это немного странно. Другие языки реализуют
что-то под названием **классы**, где **класс** определяет как объект должен выглядеть и затем
вы используете **new** оператор, чтобы создать объект. И вот что функция-конструктор пытается
имитировать.

С другой стороны, многие считают, что лучше сфокусироваться на том, что JS использует
прототипное наследование, а не то что называется классическим наследованием и принять его.

И есть еще один способ создания объектов, который не пытается имитировать другие языки программирования
и это то, что все более новые браузеры уже встроили в себя. Он называется **Object.create**.

Теперь давайте посмотрим на него и подумаем о чистом прототипном наследовании.

Я собираюсь создать новый объект используя синтаксис литерала объекта и я дам ему firstname
со значением 'Default' и lastname так же со значением 'Default'. И давайте сделаем в этот раз
метод greet. 
 
 ```javascript
var person = {
    firstname: 'Default',
    lastname: 'Default',
    greet: function() {
      return 'Hi ' + this.firstname
    }
}
```

Кстати, я должен использовать **this**, потому что **this** это ключевое слово, когда я
ссылаюсь на объект. Если я не исопльзвал бы **this** то переменная бы искалась в контексте
функции в которой была вызвана, в контекте вызова. Не найдя этой переменой, вышла бы наружу
и продолжила бы поиск в глобальном контексте исполнения и не обнаружила бы ее там, потому что
переменная находится внутри объекта person (объекты не создаются новых контекстов исполнения). 

Теперь я собираюсь использовать кое что встроенное в большинство современных браузеров, чтобы
создать новый объект. Все о чем мы говорим в данной теме - все о создание объекта, и все это
построенние одних и тех же вещей. Я не изменяю как вещи работают, но изменяю как я могу 
создавать их.

Так я хочу создать объект, и установить его прототип. Поэтому я создаю переменную **john**,
которая будет равна **Object**. Это базовая концепция объекта в JS. Вызываю метод **create**
и передаю туда объект **person**.

```javascript
var john = Object.create(person);
```

И что же он создает, когда мы используем такой способ? давайте попробем сделать console.log().

```javascript
console.log(john); // приходит объект person
```

Мы получаем пустой объект, у которого протитом является объект person.

И если мы изменим поля в нашем пустом объекте john, у которого прототипом является объект person

```javascript
john.firstname = 'John';
john.lastname = 'Doe';
john.greet(); // возвращает "Hi John"
```

То у нас вернется строка "Hi John", но в прототипе поля не изменятся. Это и есть чистое
прототипное наслдеование. Другого понятия, которое пытается определить структуру объекта,
не существует. Вы просто создаете объект, затем создаете новые объекты, из которых указываете
на другие объекты как на прототипы. Если вы хотите определить новый объект, вы создаете новый
объект, который становится основных для всех остальных. А затем вы просто переписываете скрытые
свойства и методы на этих созданных объекта с помощью установки значений этих свойств и методов.

Если вам нужно поддерживать старый браузеры, где нет встроенного **Object.create**, то 
можно использовать polyfill:

```javascript
if(!Object.create) {
    Object.create = function (o) {
        if (arguments.length > 1) {
            throw new Error('Object.create implementation'
            + ' only accepts the first parameter.');
        }
        function F() {}
        F.prototype = o;
        return new F();
    };
}
```


