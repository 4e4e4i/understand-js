# ES6 and Classes

Следующая версия JS, EcmaScript 2015 или EcmaScript 6 или ES6, как хотите так и называйте,
имеем новый концепт. И это еще один способ создания объекта и установки прототипа.

Давайте взглянем на **классы**.

Классы чрезвычайно популярны в других языках программирования. Они представляют собой способ
определения объекта, определения его методов и свойств. 

Так как же выглядят классы?

```javascript
class Person {
    
    constructor(firstname, lastname) {
        this.firstname = firstname;
        this.lastname = lastname;
    }
    
    great() {
        return 'Hi ' + firstname;
    }
}
```

JavaScript класс определяет объект. Так же как мы делали и до этого. Мы имеем **constructor**
который действует подобное функциям-конструкторам, что мы видели до этого, там мы можем
предустанавливать его значения. Так когда я создаю нового **person** в данном случае, например:

```javascript
var john = new Person('John', 'Doe');
```

Я использую **new**, чтобы сделать это. Я могу передать firstname and lastname и затем это
ключевое слово будет установлено на тот момент, когда создается новый объект,
который создается.
Я так же могу иметь методы как greet, находящийся внутри класса. И он просто доступен.

Но есть и проблема, люди приходящие из других языков программирования, когда они видят 
класс, они думаю "Ох, отлично. Это точно так же как я использовал до этого". Но разница в том,
что в других языках программирования класс - это не объект, это просто определение, как шаблон.
Он говорит нам как объекты должны выглядеть. Но вы не по-настоящему не получаете объект до тех пор,
пока не используете **new**. Но JavaScript хоть и добавляет ключевое слово class, все равно
не имеет классов в этом смысле. **Потому что это и есть объект в JavaScript**

Этот class Person и есть объект, который создан. И когда вы создаете новые объекта из этого
объекта - то все нормально.

Однако я опасаюсь, что вместо того, чтобы оценить различия и красоту наследования прототипов,
те, кто происходят из других языков программирования, просто увидят ключевое слово класса и
немедленно начнут проектировать структуры объектов так, как это делается в C#, Java или C++.
Я думаю, что это большая ошибка. И еще я устал от того, что мне все еще приходится использовать
ключевое слово **new**. Это все еще попытка ублажить тех, кто пришел из других языков.
Но это определенно лучше, чем использовать функции-конструкторы, потому что по крайней мере
язык сможет сказать, что это класс. И ты должен использовать **new** ключевое слово, так
движок может остановить тебя от совершения чего-то очень глупого.
 
Моя надежда что если вы изучаете JavaScript, если вы используете JavaScript, вы остановитесь
так же, как этот класс пытается вам помочь, и поймете, что происходит под капотом, и оцените
прототипное наследство. Простота в сравнении с попыткой подражать какому-то другому языку
программирования.

Между прочим как установить прототип? Ну, для этого есть новое ключевое слово:

```javascript
class InformalPerson extends Preson {
    
    constructor(firstname, lastname) {
        super(firstname, lastname)
    }
    
    greet() {
        return 'Yo ' + firstname;
    }
    
}
```

Давайте предположим, что я создал Informal person, или person - наш прототип. Я просто
использую ключевое слово **extends**. И оно устанавливает прототип для любого из моих объектов
созданных с этим классом, по сути это __ __proto____ свойство в Chrome. И в моем constructor,
я могу вызвать ключевое слово **super**. Который мы просто будем называть конструктором объекта, 
который является моим прототипом. Так я могу передать мои начальные значения вниз цепи. И затем
я могу обойти или прятать, как я и делал с object.create.






