# Conceptual Aside: Built-In Function Constructors (Встроенные функции-конструкторы)

Теперь, когда мы понимаем что такое функция-конструктор, мы можем поговорить в этом консептуальном
отступлении о встроенных функциях-конструкторах в JS. функциях-конструкторах, которые находятся внутри архитектуры JavaScript и готовы к
использованию внутри JavaScript движка, и как их можно использовать.

Откроем консоль в режиме разработчика, например Google Chrome браузере. И позвольте показать
некоторые из встроенных функции-конструкторов. Это означает, что есть некоторые функции
и прототипы функций, которые существуют и многие вы могли уже использовать, возможно даже
не подозревая об этом.

Например, я могу сказать, что некоторое значение  - **new number**.
Зададим ему какое-либо число или даже передадим туда строку, чтобы он переконвертировал его
в число 

```javascript
var a = new Number(3);
```

И что же это? Мы используем **new** оператор, поэтому это функция, функция-конструктор.
И даже JS использует договоренность именования с заглавной буквы. Так мы создали новое число.
Если мы вызовем нашу переменную, мы заметим, что это не число. Это не примитив, это объект.
Потому что функция-конструктор создает объект. И затем добавляет примитивное значение внутрь
этого объекта. Но из-за того что это объект, у него есть прототип.

и если мы попробуем написать

```javascript
Number.prototype
```

Мы получим доступ ко всем объектам прототипа и так же встроенным методам, таким как **toPrecision**
или **toFixed**, для математических вычислений и преобразований с числами. 

Это значит, что я могу сделать

```javascript
a.toFixed(2)
```

И мы преобразуем наше число, заданое ранее.

Давайте попробуем кое что другое. Как насчет того, чтобы приравнять A к **new String**??

```javascript
var a = new String("John")
```

Теперь **a.** имеет доступ к целой куче методов для строк. Потому что эти методы находятся в прототипе
String.

```javascript
a.indexOf("J")
```

Так мы можем определить позицию символа в строке, например.
 
Если мы вызовем **a**, то увидим, что это не примитив, это не строка. Это объект, который
мы создали с помощью **new**. 

Иногда JS может понимать, что вы хотите получить от примитива и работать с ним как с объектом.
Например я могу написать вот так:

```javascript
"John".length
```

Хоть примитив и не имеет свойства и методов, но движок JS упаковал его внутрь объекта строки,
который имеет все эти свойства и методы, и затем автоматически дал доступ к ним.

По сути тоже самое происходит, если мы используем **new** оператор и затем вызовем length
```javascript
new String("John")
```

В любое время, когда вы видите оператор **new**, может быть **new Date**, который принимает строку
в конструкторе функции.

```javascript
var a = new Date("3/1/2015")
```

Это всего-лишь функция и я вызвал **new** и получил назад объект. Если мы вызовем переменную
A и добавим **точку**, то получим целую кучу свовойств и методов, которые JS предоставляет нам
для данной функции (Date).

Давайте посмотрим, что мы еще можем делать с нашими встроенными функциями.
Перейдем к файлу app.js и предположим, что я хочу добавить новую фичу ко всем строкам в JS.
Мы уже видели что JS упаковывает строки, конвертирует примитив к объект строки, который 
имет кучу свойств и методов. И он указывает на прототип, где эти методы и свойства по-настоящему
живут, и ничего не мешает мне добавить в них что-нибудь еще.

Так я могу перейти к прототипу строки, на которую ссылаются все объекты строк, для получения
методов и свойств. Например я хочу добавить новую фичу isLengthGreaterThan, будем передавать
входящим параметром лимит и возвращать true/false от **this** (который будет указывать на объект строки) длины
больше лимита

```javascript
String.prototype.isLengthGreaterThan = function(limit) {
  return this.length > limit;
}
```

Теперь мы можем вывести лог и получим True либо False

```javascript
console.log("John".isLengthGreaterThan(3))
```

Давайте проверим тоже самое с числами. Попробуем добавить функцию выявления положительного либо
отрицательного числа

```javascript
Number.prototype.isPositive = function() {
  return this > 0;
}
```

Если попытаемся вызвать данный метод через объект числа, с помощью метода взятого из прототипа

```javascript
3.isPositive()
```

То получим ошибку, Unexpected token ILLEGAL! Почему? Потому что JS конвертирует строки в объект
автоматически, а вот с числами такого делать он не умеет. 

Зато мы можем вернуть объект с помощью конструктора функции и вызвать этот метод из него

```javascript
var a = new Number(3);
a.isPositive()
```
